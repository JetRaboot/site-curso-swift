<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="styles.css">
  <title>Módulo 2</title>
</head>
<body>
  <header>
    <h1>Módulo 2</h1>
  </header>
  <div class="container">
  <main>
    <section id="module-content">
      <h2 class="module-title">Conteúdo do Módulo 2</h2>
      <div class="video-container">
        <iframe width="560" height="315" src="https://www.youtube.com/embed/PA186hHpuoM?si=-3fYhdLmP0YCIgoL" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
      </div>
      <p class="module-description">Bem-vindo ao Módulo 2 do curso! Neste módulo, você aprenderá sobre
        Ponteiros, Struct, Arquivos e Exemplos
      </p>
      <h3>Ponteiros</h3>
      <p class="module-description">
        Em Swift, o conceito de ponteiros é tratado de maneira mais abstrata e segura em 
        comparação com linguagens de programação que permitem manipulação direta de memória, 
        como C ou C++. Isso se deve à abordagem de segurança e gerenciamento de memória que 
        Swift adota.
      </p>
      <p class="module-description">
        Swift foi projetado para minimizar erros comuns de programação, como referências 
        nulas e acessos inválidos à memória. A linguagem usa um sistema de gerenciamento 
        de memória chamado ARC (Contagem Automática de Referência), que cuida automaticamente 
        do ciclo de vida dos objetos e libera a memória quando não há mais referências para eles.
      </p>
      <p class="module-description">
        Na prática, você não precisa lidar diretamente com ponteiros como faria em C ou C++, 
        mas ainda pode trabalhar com referências a objetos. Aqui estão algumas informações relevantes:
      </p>
      <p class="module-description">
        1- Referências e Classes:
      </p>
      <p class="module-description">
        Em Swift, as classes são tipos de referência. Quando você cria uma instância 
        de uma classe e atribui a uma variável, na verdade você está criando uma 
        referência à instância da classe, não uma cópia direta dos dados.
      </p>
      <pre>
        <code>
          class Pessoa {
            var nome: String
            init(nome: String) {
                self.nome = nome
            }
          }
        
          var pessoa1 = Pessoa(nome: "Alice")
          var pessoa2 = pessoa1 // pessoa2 se torna uma referência para a mesma instância
          pessoa1.nome = "Eva"
        
          print(pessoa2.nome) // Isso imprimirá "Eva"        
        </code>
      </pre>
      <p class="module-description">
        2- Insegurança com Referências Circulares:
      </p>
      <p class="module-description">
        É importante lembrar que referências circulares entre objetos podem levar a 
        vazamentos de memória. Isso ocorre quando dois ou mais objetos mantêm referências 
        uns aos outros, impedindo o ARC de liberar a memória.
      </p>
      <p class="module-description">
        3- Unowned e Weak References:
      </p>
      <p class="module-description">
        Em Swift, para evitar referências circulares e lidar com objetos que podem ser 
        liberados, você pode usar referências "unowned" (não mantém uma contagem de referências) 
        ou "weak" (opção mais segura que pode se tornar nula automaticamente).
      </p>
      <pre>
        <code>
          class ObjetoA {
            var objetoB: ObjetoB?
          }
        
          class ObjetoB {
            weak var objetoA: ObjetoA?
          }        
        </code>
      </pre>
      <p class="module-description">
        Em resumo, embora Swift não lide diretamente com ponteiros no mesmo sentido que 
        C ou C++, ela gerencia referências a objetos de maneira segura por meio do ARC. 
        Isso permite que você se concentre na lógica do aplicativo sem se preocupar com 
        detalhes de alocação e liberação de memória.
      </p>
      <h3>Struct</h3>
      <p class="module-description">
        Em Swift, struct é uma abreviação de "structure" (estrutura) e é um tipo de dado 
        composto que permite agrupar valores relacionados em uma única unidade. 
        As estruturas em Swift são usadas para criar tipos de dados mais complexos 
        que podem conter propriedades (variáveis e constantes) e métodos. Aqui estão 
        alguns conceitos importantes sobre struct em Swift:
      </p>
      <p class="module-description">
        Declaração de Struct:
      </p>
      <p class="module-description">
        Aqui está a sintaxe básica para declarar uma struct em Swift:
      </p>
      <pre>
        <code>
          struct NomeDaStruct {
            // Propriedades e métodos
          }        
        </code>
      </pre>
      <p class="module-description">
        1- Propriedades:
      </p>
      <p class="module-description">
        Você pode adicionar propriedades à sua estrutura para armazenar valores. 
        As propriedades podem ser variáveis (var) ou constantes (let):
      </p>
      <pre>
        <code>
          struct Pessoa {
            var nome: String
            var idade: Int
          }
        
          var pessoa1 = Pessoa(nome: "João", idade: 30)        
        </code>
      </pre>
      <p class="module-description">
        2- Métodos:
      </p>
      <p class="module-description">
        Você também pode adicionar métodos a uma estrutura para adicionar comportamento:
      </p>
      <pre>
        <code>
          struct Retângulo {
            var largura: Double
            var altura: Double
        
            func calcularÁrea() -> Double {
                return largura * altura
            }
          }
        
          let retangulo = Retângulo(largura: 5.0, altura: 3.0)
          let área = retangulo.calcularÁrea() // 15.0        
        </code>
      </pre>
      <p class="module-description">
        3- Valor Semântico:
      </p>
      <p class="module-description">
        As estruturas são tipos de valor em Swift. Isso significa que, quando uma 
        estrutura é passada como argumento para uma função ou atribuída a uma nova 
        variável, uma cópia independente da estrutura é criada:
      </p>
      <pre>
        <code>
          var pessoa2 = pessoa1
          pessoa2.nome = "Maria"
          print(pessoa1.nome) // "João"
          print(pessoa2.nome) // "Maria"
        </code>
      </pre>
      <p class="module-description">
        4- Inicializadores Automáticos:
      </p>
      <p class="module-description">
        Swift fornece um inicializador padrão para estruturas, mas você pode definir 
        seus próprios inicializadores personalizados:
      </p>
      <pre>
        <code>
          struct Endereço {
            var rua: String
            var cidade: String
            var CEP: String
        
            init(rua: String, cidade: String, CEP: String) {
                self.rua = rua
                self.cidade = cidade
                self.CEP = CEP
            }
          }        
        </code>
      </pre>
      <p class="module-description">
        5- Herança e Protocolos:
      </p>
      <p class="module-description">
        Diferente de classes, as estruturas não suportam herança. No entanto, 
        elas podem conformar-se a protocolos para adicionar funcionalidades comuns:
      </p>
      <pre>
        <code>
          protocol Imprimível {
            func imprimirDetalhes()
          }
        
          struct Carro: Imprimível {
            var marca: String
        
            func imprimirDetalhes() {
                print("Carro da marca \(marca)")
            }
          }        
        </code>
      </pre>
      <p class="module-description">
        Em resumo, as estruturas em Swift são usadas para criar tipos de valor contendo 
        propriedades e métodos. Elas são frequentemente usadas para representar conceitos 
        simples ou objetos pequenos e são uma parte fundamental da programação em Swift.
      </p>
      <h3>Arquivos</h3>
      <p class="module-description">
        Em Swift, você pode trabalhar com arquivos para realizar operações de leitura 
        e gravação de dados. Existem várias maneiras de lidar com arquivos, 
        incluindo a leitura e gravação de texto e a manipulação de dados binários. 
        Vou abordar algumas das principais formas de lidar com arquivos em Swift:
      </p>
      <p class="module-description">
        1- Trabalhando com Arquivos de Texto:
      </p>
      <p class="module-description">
        a. Leitura de Arquivos de Texto:
      </p>
      <p class="module-description">
        Você pode usar o tipo String para ler o conteúdo de um arquivo de texto:
      </p>
      <pre>
        <code>
          if let content = try? String(contentsOfFile: "caminho/do/arquivo.txt", encoding: .utf8) {
            print(content)
          }        
        </code>
      </pre>
      <p class="module-description">
        b. Gravação em Arquivos de Texto:
      </p>
      <p class="module-description">
        Para gravar dados em um arquivo de texto, use o método write(to:atomically:encoding:) da 
        classe String:
      </p>
      <pre>
        <code>
          let content = "Conteúdo a ser gravado no arquivo"
          try? content.write(toFile: "caminho/do/arquivo.txt", atomically: true, encoding: .utf8)
        </code>
      </pre>
      <p class="module-description">
        2- Trabalhando com Arquivos Binários:
      </p>
      <p class="module-description">
        a. Leitura de Arquivos Binários:
      </p>
      <p class="module-description">
        Para ler dados binários de um arquivo, você pode usar Data:
      </p>
      <pre>
        <code>
          if let data = try? Data(contentsOf: URL(fileURLWithPath: "caminho/do/arquivo.bin")) {
            // Use os dados binários
          }        
        </code>
      </pre>
      <p class="module-description">
        b. Gravação em Arquivos Binários:
      </p>
      <p class="module-description">
        Para gravar dados binários em um arquivo, use o método write(to:options:) da classe Data:
      </p>
      <pre>
        <code>
          let data = Data(/* Seus dados binários */)
          try? data.write(to: URL(fileURLWithPath: "caminho/do/arquivo.bin"))
        </code>
      </pre>
      <p class="module-description">
        3- Diretórios e Gerenciamento de Caminhos:
      </p>
      <p class="module-description">
        Você pode trabalhar com caminhos de arquivo usando a classe URL e o tipo FileManager:
      </p>
      <pre>
        <code>
          let fileManager = FileManager.default

          // Obter diretório temporário
          let temporaryDirectory = fileManager.temporaryDirectory

          // Obter URL para diretório de documentos
          if let documentsDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first {
              // Use documentsDirectory
          }

          // Verificar se um arquivo existe
          let fileExists = fileManager.fileExists(atPath: "caminho/do/arquivo.txt")

          // Mover arquivo
          try? fileManager.moveItem(atPath: "antigo/caminho", toPath: "novo/caminho")
        </code>
      </pre>
      <p class="module-description">
        Lembre-se de que operações de arquivo podem gerar exceções e podem exigir tratamento de 
        erros adequado, como é o caso com as chamadas try? nas operações acima. Certifique-se 
        de tratar os erros adequadamente em cenários de produção.
      </p>
      <p class="module-description">
        Em resumo, Swift fornece uma série de ferramentas para lidar com arquivos, desde 
        operações de texto até operações binárias. O uso de tipos como String e Data, 
        juntamente com as classes URL e FileManager, permite que você realize tarefas 
        de leitura e gravação de arquivos de maneira eficaz.
      </p>
      <h3>Exemplos</h3>
      <p class="module-description">
        Ponteiros
      </p>
      <pre>
        <code>
          class Pessoa {
            var nome: String
            init(nome: String) {
                self.nome = nome
            }
          }
          
          var pessoa1 = Pessoa(nome: "Alice")
          var pessoa2 = pessoa1
          pessoa2.nome = "Eva"
          
          print(pessoa1.nome) // "Eva"
          print(pessoa2.nome) // "Eva"        
        </code>
      </pre>
      <p class="module-description">
        Struct
      </p>
      <pre>
        <code>
          struct Retangulo {
            var largura: Double
            var altura: Double
        
            func calcularÁrea() -> Double {
                return largura * altura
            }
          }
          
          let retangulo = Retangulo(largura: 5.0, altura: 3.0)
          let área = retangulo.calcularÁrea() // 15.0        
        </code>
      </pre>
      <p class="module-description">
        Arquivos
      </p>
      <pre>
        <code>
          import Foundation

          // Caminho do arquivo
          let caminhoDoArquivo = FileManager.default.temporaryDirectory.appendingPathComponent("arquivo.txt")

          // Escrever em um arquivo de texto
          let conteudoParaEscrever = "Olá, mundo!"
          do {
              try conteudoParaEscrever.write(to: caminhoDoArquivo, atomically: true, encoding: .utf8)
          } catch {
              print("Erro ao escrever no arquivo: \(error)")
          }

          // Ler de um arquivo de texto
          do {
              let conteudoLido = try String(contentsOf: caminhoDoArquivo, encoding: .utf8)
              print(conteudoLido) // Imprime: "Olá, mundo!"
          } catch {
              print("Erro ao ler o arquivo: \(error)")
          }
        </code>
      </pre>
      <button class="back-page" onclick="goToPreviousPage()">Voltar para a Página anterior</button>
      <button class="back" onclick="goToMainMenu()">Menu principal</button>
      <button class="next" onclick="goToNextPage()">Próxima Página</button>
    </section>
</main>
</div>
<footer>
  <p>&copy; 2023 made by João Renó</p>
</footer>
<script>
    function goToMainMenu() {
      window.location.href = "index.html";
    }
    function goToNextPage() {
      window.location.href = "modulo3.html";
    }
    function goToPreviousPage() {
      window.location.href = "modulo1.html";
    }
  </script>
</body>
</html>